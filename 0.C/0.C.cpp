/*
C. Путешествие по Москве
Ограничение времени	2 секунды
Ограничение памяти	256Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt

Мэрия Москвы основательно подготовилась к празднованию тысячелетия города в 2147 году, построив под столицей 
бесконечную асфальтированную площадку, чтобы заменить все существующие в городе автомобильные дороги. 
В память о кольцевых и радиальных дорогах разрешили двигаться по площадке только двумя способами:

1. В сторону точки начала координат или от неё. При этом из точки начала координат разрешено двигаться в любом направлении.

2. Вдоль окружности с центром в начале координат и радиусом, который равен текущему расстоянию до начала координат. 
Двигаться вдоль такой окружности разрешается в любом направлении (по или против часовой стрелки).

Вам, как ведущему программисту ответственной инстанции поручено разработать модуль, который будет определять 
кратчайший путь из точки A, с координатами (xA, yA) в точку B с координатами (xB, yB). Считайте, что менять 
направление движения можно произвольное количество раз, но оно должно всегда соответствовать одному из двух 
описанных выше вариантов.

Формат ввода
В первой строке ввода заданы четыре целых числа xA, yA, xB и yB, по модулю не превосходящие 10^6.

Формат вывода
Выведите одно число — минимальное расстояние, которое придётся преодолеть по пути из точки A в точку B, 
если не нарушать правил дорожного движения. Ваш ответ будет принят, если его абсолютная или относительная погрешность 
не превосходит 10^-6.
*/	



#include <iostream>
#include <math.h>

const float pi = 3.14159265;

struct Vec {
	double x, y;
	double len() {
		return sqrt(pow(x, 2) + pow(y, 2));
	}
};

int main()
{
	Vec v1, v2;
	std::cin >> v1.x >> v1.y >> v2.x >> v2.y;

	double ang1 = atan2(v1.y, v1.x);
	if (abs(round(ang1) - ang1) < 0.00001) ang1 = round(ang1);
	double ang2 = atan2(v2.y, v2.x);
	if (abs(round(ang2) - ang2) < 0.00001) ang2 = round(ang2);
	double ang = abs(ang1 - ang2);

	if (ang >= pi) ang = 2 * pi - ang;

	double len1 = v1.len(), len2 = v2.len();
	if (abs(round(len1) - len1) < 0.00001) len1 = round(len1);
	if (abs(round(len2) - len2) < 0.00001) len2 = round(len2);

	if (len1 > len2) {
		std::swap(v1, v2);
		std::swap(len1, len2);
	}

	double res;

	if (ang < 2) {
		res = ang * len1 + len2 - len1;
	}
	else {
		res = len1 + len2;
	}

	std::cout << std::fixed << res << '\n';

	return 0;
}
